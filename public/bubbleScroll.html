<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <title>Carrusel Esférico (Minimal)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root{
      --altura: 260px;          /* altura del carrusel (se ajusta en responsive) */
      --gap: 22px;              /* separación entre burbujas */
      --velocidad: 90;          /* px/seg (se puede modificar en JS también) */
      --escala-min: 0.65;       /* escala en bordes (derecha/izquierda) */
      --escala-max: 1.15;       /* escala hacia el centro */
      --opacidad-min: 0.15;     /* opacidad en bordes */
      --opacidad-max: 1;        /* opacidad al centro */
      --burbuja-base: 190px;    /* tamaño base de burbuja (antes de escala) */
      --shine: rgba(255,255,255,.35);
    }

    /* Responsive */
    @media (max-width: 900px){
      :root{ --altura: 220px; --burbuja-base: 160px; }
    }
    @media (max-width: 600px){
      :root{ --altura: 180px; --burbuja-base: 130px;}
    }

    /* Contenedor del carrusel (sin fondo, sin sombras) */
    .carousel{
      position: relative;
      width: 100vw;            /* ocupa el ancho de la ventana (ajústalo si prefieres) */
      height: var(--altura);
      overflow: hidden;
      background: transparent; /* SIN fondo */
      border: none;
      border-radius: 0;
      user-select:none;
      -webkit-user-select:none;
      isolation:isolate;
    }

    .track{
      position:absolute;
      inset:0;
      will-change: transform;
    }

    /* Esfera */
    .bubble{
      position:absolute;
      top:50%;
      width: var(--burbuja-base);
      height: var(--burbuja-base);
      transform: translate3d(0,-50%,0) scale(1);
      transform-origin: center center;
      border-radius: 50%;
      overflow: hidden;
      opacity: 0;
      will-change: transform, opacity;
      background: #111; /* solo como respaldo por si la imagen tarda (no es “fondo” del carrusel) */
      outline: 1px solid rgba(255,255,255,.06);
    }

    .bubble::before{
      /* brillo sutil para dar “cuerpo” a la esfera */
      content:"";
      position:absolute; inset:0;
      background:
        radial-gradient(120% 90% at 20% 10%, var(--shine) 0%, transparent 40%) ,
        radial-gradient(100% 100% at 80% 85%, rgba(0,0,0,.4) 0%, transparent 50%);
      mix-blend-mode: screen;
      pointer-events:none;
    }

    .bubble img{
      width:100%;
      height:100%;
      object-fit: cover;
      display:block;
      filter: saturate(1.05) contrast(1.02);
      transform: scale(1.02);
    }
  </style>
</head>
<body>
  <!-- Solo el carrusel -->
  <section class="carousel" aria-label="Carrusel de imágenes esféricas">
    <div class="track" aria-live="off"></div>
  </section>

  <script>
    /**
     * Carrusel Esférico (versión minimal)
     * - Movimiento continuo de derecha a izquierda
     * - Escala y opacidad varían según la posición X (más grande/visible al centro)
     * - Reciclaje: lo que sale por la izquierda reaparece a la derecha
     * - Sin textos, sin botones, sin pausa/drag: animación infinita
     */

    // === Imágenes de ejemplo (reemplaza por las tuyas) ===
    const IMAGES = [
      "https://picsum.photos/id/1015/800/800",
      "https://picsum.photos/id/1025/800/800",
      "https://picsum.photos/id/1003/800/800",
      "https://picsum.photos/id/1005/800/800",
      "https://picsum.photos/id/1011/800/800",
      "https://picsum.photos/id/1016/800/800",
      "https://picsum.photos/id/1018/800/800",
      "https://picsum.photos/id/1027/800/800",
      "https://picsum.photos/id/1035/800/800",
      "https://picsum.photos/id/1041/800/800"
    ];

    // Utilidades
    const clamp = (v, a, b) => Math.min(b, Math.max(a, v));
    const lerp  = (a, b, t) => a + (b - a) * t;

    // Elementos
    const carousel = document.querySelector('.carousel');
    const track    = document.querySelector('.track');

    // Estado
    let width = carousel.clientWidth;
    let baseSize = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--burbuja-base'));
    let gap = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--gap'));
    let speed = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--velocidad')); // px/seg
    let scaleMin = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--escala-min'));
    let scaleMax = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--escala-max'));
    let opMin = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--opacidad-min'));
    let opMax = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--opacidad-max'));

    let bubbles = [];      // {el, x, w, imgIndex}
    let lastTime = performance.now();

    function createBubbles(){
      track.innerHTML = '';
      bubbles.length = 0;

      const totalWidthPerItem = baseSize + gap;
      const count = Math.ceil(width / totalWidthPerItem) + 3;

      let x = width * 0.15; // empieza un poco fuera de foco a la derecha
      let imgIndex = 0;

      for (let i = 0; i < count; i++){
        const el = document.createElement('div');
        el.className = 'bubble';

        const img = document.createElement('img');
        img.alt = `Imagen ${i+1}`;
        img.decoding = 'async';
        img.loading  = 'lazy';
        img.src = IMAGES[imgIndex % IMAGES.length];
        imgIndex++;

        el.appendChild(img);
        track.appendChild(el);

        const w = baseSize;
        bubbles.push({ el, x, w, imgIndex });
        x += w + gap;
      }
    }

    function repositionOnResize(){
      width = carousel.clientWidth;
      baseSize = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--burbuja-base'));
      gap = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--gap'));

      const totalWidthPerItem = baseSize + gap;
      let x = 0;
      for (let i = 0; i < bubbles.length; i++){
        bubbles[i].w = baseSize;
        bubbles[i].x = x;
        x += totalWidthPerItem;
      }
    }

    function recycling(item){
      // cuando sale por la izquierda, reaparece a la derecha
      if (item.x + item.w * scaleMin < 0){
        let maxX = -Infinity;
        for (const b of bubbles) maxX = Math.max(maxX, b.x);
        item.x = maxX + item.w + gap;

        // rota la fuente de imagen para variedad
        item.imgIndex = (item.imgIndex + 1) % IMAGES.length;
        const img = item.el.querySelector('img');
        if (img) img.src = IMAGES[item.imgIndex];
      }
    }

    function updateItemAppearance(item){
      const centerX = item.x + item.w/2;
      const p = clamp(centerX / width, 0, 1); // 0..1
      const s = 1 - Math.pow(Math.abs(p - 0.5) / 0.5, 0.85); // pico al centro

      const scale = lerp(scaleMin, scaleMax, s);
      const opacity = lerp(opMin, opMax, s);

      item.el.style.transform = `translate3d(${item.x}px, -50%, 0) scale(${scale})`;
      item.el.style.opacity = opacity;
    }

    function tick(now){
      const dt = Math.min(0.05, (now - lastTime)/1000); // hasta 50ms
      lastTime = now;

      for (const item of bubbles){
        item.x -= speed * dt;
        recycling(item);
        updateItemAppearance(item);
      }

      requestAnimationFrame(tick);
    }

    // Redimensionado
    const onResize = ()=>{
      repositionOnResize();
      for (const b of bubbles) updateItemAppearance(b);
    };
    window.addEventListener('resize', onResize);

    // Init
    createBubbles();
    for (const b of bubbles) updateItemAppearance(b);
    requestAnimationFrame((t)=>{ lastTime=t; tick(t); });

    // APIs útiles opcionales por si quieres ajustar desde consola:
    window.carouselSetSpeed  = (pxPerSec)=>{ speed = +pxPerSec; };
    window.carouselSetImages = (urls=[])=>{
      if (!urls.length) return;
      for (let i=0;i<bubbles.length;i++){
        bubbles[i].imgIndex = i % urls.length;
        bubbles[i].el.querySelector('img').src = urls[bubbles[i].imgIndex];
      }
    };
  </script>
</body>
</html>
